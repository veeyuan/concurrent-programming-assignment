/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 *
 * @author Liow Jing Wen
 */
public class PlotPoints extends javax.swing.JPanel {

    /**
     * Creates new form PlotPoints
     */
    private static List<Point> pointList;
    private static List<Player> playerList;
    Graphics g;
    int xLength;
    int yLength;
    
    private PlotPointsFrame frame;
    
    private Map<Integer, Color> mapColors;
    
    public PlotPoints(List<Point> pointList, List<Player> playerList, PlotPointsFrame frame) {
        this.pointList = pointList;
        this.playerList = playerList;
        this.frame = frame;
        initComponents();
        
        //initialise HashMap to map integer (row) to a specific color
        mapColors = new HashMap<Integer, Color>();                

        for (int i=0; i<playerList.size(); i++) {
            Player player = playerList.get(i);
            //use random color for each player respectively
                int R = (int) (Math.random( )*256);
                int G = (int)(Math.random( )*256);
                int B= (int)(Math.random( )*256);
                Color randomColor = new Color(R, G, B);

                mapColors.put(i, randomColor);
        }
    }
      
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1100, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1050, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    // x-axis coord constants
    public static final int X_AXIS_FIRST_X_COORD = 20; 
    public static final int X_AXIS_SECOND_X_COORD = 1040;
    public static final int X_AXIS_Y_COORD = 1020;
 
    // y-axis coord constants
    public static final int Y_AXIS_FIRST_Y_COORD = 0;
    public static final int Y_AXIS_SECOND_Y_COORD = 1020;
    public static final int Y_AXIS_X_COORD = 20;
 
    //arrows of axis are represented with "hipotenuse" of 
    //triangle
    //define length of "hipotenuse" of that triangle
    public static final int FIRST_LENGHT = 10;
    public static final int SECOND_LENGHT = 5;
 
    // size of start coordinate lenght
    public static final int ORIGIN_COORDINATE_LENGHT = 3;

    // distance of coordinate strings from axis
    public static final int AXIS_STRING_DISTANCE = 20;
    
    @Override
    public void paintComponent(Graphics g){
        super.paintComponent(g);
        this.g = g;
        Graphics2D g2 = (Graphics2D) g;
  
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
         RenderingHints.VALUE_ANTIALIAS_ON);
  
        // x-axis
        g2.drawLine(X_AXIS_FIRST_X_COORD, X_AXIS_Y_COORD,
           X_AXIS_SECOND_X_COORD, X_AXIS_Y_COORD);
        // y-axis
        g2.drawLine(Y_AXIS_X_COORD, Y_AXIS_FIRST_Y_COORD,
           Y_AXIS_X_COORD, Y_AXIS_SECOND_Y_COORD);
  
        // x-axis arrow
        g2.drawLine(X_AXIS_SECOND_X_COORD - FIRST_LENGHT,
           X_AXIS_Y_COORD - SECOND_LENGHT,
           X_AXIS_SECOND_X_COORD, X_AXIS_Y_COORD);
        g2.drawLine(X_AXIS_SECOND_X_COORD - FIRST_LENGHT,
          X_AXIS_Y_COORD + SECOND_LENGHT,
          X_AXIS_SECOND_X_COORD, X_AXIS_Y_COORD);
  
        // y-axis arrow
        g2.drawLine(Y_AXIS_X_COORD - SECOND_LENGHT,
           Y_AXIS_FIRST_Y_COORD + FIRST_LENGHT,
           Y_AXIS_X_COORD, Y_AXIS_FIRST_Y_COORD);
        g2.drawLine(Y_AXIS_X_COORD + SECOND_LENGHT, 
           Y_AXIS_FIRST_Y_COORD + FIRST_LENGHT,
           Y_AXIS_X_COORD, Y_AXIS_FIRST_Y_COORD);
  
        // origin Point
        g2.fillOval(
          X_AXIS_FIRST_X_COORD - (ORIGIN_COORDINATE_LENGHT / 2), 
          Y_AXIS_SECOND_Y_COORD - (ORIGIN_COORDINATE_LENGHT / 2),
          ORIGIN_COORDINATE_LENGHT, ORIGIN_COORDINATE_LENGHT);

        // draw text "X" and draw text "Y"
        g2.drawString("X", X_AXIS_SECOND_X_COORD - AXIS_STRING_DISTANCE / 2,
           X_AXIS_Y_COORD + AXIS_STRING_DISTANCE);
        g2.drawString("Y", Y_AXIS_X_COORD - AXIS_STRING_DISTANCE,
           Y_AXIS_FIRST_Y_COORD + AXIS_STRING_DISTANCE / 2);
        g2.drawString("(0, 0)", X_AXIS_FIRST_X_COORD - AXIS_STRING_DISTANCE,
           Y_AXIS_SECOND_Y_COORD + AXIS_STRING_DISTANCE);
  
        // numerate axis
        int xCoordNumbers = 1000;
        int yCoordNumbers = 1000;
        xLength = (X_AXIS_SECOND_X_COORD - X_AXIS_FIRST_X_COORD)
            / xCoordNumbers;
        yLength = (Y_AXIS_SECOND_Y_COORD - Y_AXIS_FIRST_Y_COORD)
            / yCoordNumbers;
  
        // draw x-axis numbers
        for(int i = 0; i <= xCoordNumbers; i+= 50) {
         g2.drawLine(X_AXIS_FIRST_X_COORD + (i * xLength),
           X_AXIS_Y_COORD - SECOND_LENGHT,
           X_AXIS_FIRST_X_COORD + (i * xLength),
           X_AXIS_Y_COORD + SECOND_LENGHT);
         g2.drawString(Integer.toString(i), 
           X_AXIS_FIRST_X_COORD + (i * xLength) - 3,
           X_AXIS_Y_COORD + AXIS_STRING_DISTANCE);
        }
  
        //draw y-axis numbers
        for(int i = 0; i <= yCoordNumbers; i+= 50) {
         g2.drawLine(Y_AXIS_X_COORD - SECOND_LENGHT,
           Y_AXIS_SECOND_Y_COORD - (i * yLength), 
           Y_AXIS_X_COORD + SECOND_LENGHT,
           Y_AXIS_SECOND_Y_COORD - (i * yLength));
         g2.drawString(Integer.toString(i), 
           Y_AXIS_X_COORD - AXIS_STRING_DISTANCE, 
           Y_AXIS_SECOND_Y_COORD - (i * yLength));
        }
                    
        for(int i = 0; i < pointList.size(); i ++){
            drawPointOnPanel(pointList.get(i), g, xLength, yLength);
        }
        
        //draw line for each player's connected edges
        for (int i=0; i<playerList.size(); i++) {
            Player player = playerList.get(i);
            g.setColor(mapColors.get(i));

            //to avoid table getting added with repeated rows
            //after the JFrame is minimised and reopened
            if(frame.getTable().getRowCount() < playerList.size()){
                frame.getTable().addRow(new Object[]{
                    player.getPlayerName()," ", player.getEdgeList().size()
                }); 
            }

            for (int y=0;y<player.getEdgeList().size();y++){
                Edge edge = player.getEdgeList().get(y);
                Point a = edge.getA();
                Point b = edge.getB();
                double xA = a.getxCoor();
                double yA = a.getyCoor();
                double xB = b.getxCoor();
                double yB = b.getyCoor();

                final int xAPlot = (int) (X_AXIS_FIRST_X_COORD + (xA * xLength));
                final int yAPlot = (int) (Y_AXIS_SECOND_Y_COORD - (yA * yLength));
                final int xBPlot = (int) (X_AXIS_FIRST_X_COORD + (xB * xLength));
                final int yBPlot = (int) (Y_AXIS_SECOND_Y_COORD - (yB * yLength));
                g2.drawLine(xAPlot, yAPlot, xBPlot, yBPlot);
            }

        }
        
        //changeColor for each player's 'Color' column 
        //to identify color of line by each player
        frame.changeColor(frame.getJTable(), mapColors);
    }

    
    private void drawPointOnPanel(Point point, Graphics g, int xLength, int yLength) {
        final int pointDiameter = 5;
        final int x = (int) (X_AXIS_FIRST_X_COORD + (point.getxCoor() * xLength) - pointDiameter / 2);
        final int y = (int) (Y_AXIS_SECOND_Y_COORD - (point.getyCoor() * yLength) - pointDiameter / 2);
        g.fillOval(x, y, pointDiameter, pointDiameter);
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
